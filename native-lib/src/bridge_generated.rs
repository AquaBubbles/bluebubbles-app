#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::double_parens,
    non_snake_case,
    clippy::too_many_arguments
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.75.3.

use crate::api::*;
use core::panic::UnwindSafe;
use flutter_rust_bridge::*;
use std::ffi::c_void;
use std::sync::Arc;

// Section: imports

// Section: wire functions

fn wire_newPushState_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "newPushState",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Ok(newPushState()),
    )
}
fn wire_format_e164_impl(
    port_: MessagePort,
    number: impl Wire2Api<String> + UnwindSafe,
    country: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "format_e164",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_number = number.wire2api();
            let api_country = country.wire2api();
            move |task_callback| Ok(format_e164(api_number, api_country))
        },
    )
}
fn wire_recv_wait_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "recv_wait",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            move |task_callback| Ok(recv_wait(api_state))
        },
    )
}
fn wire_send_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    msg: impl Wire2Api<DartIMessage> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "send",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            let api_msg = msg.wire2api();
            move |task_callback| send(api_state, api_msg)
        },
    )
}
fn wire_get_handles_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_handles",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            move |task_callback| get_handles(api_state)
        },
    )
}
fn wire_new_msg_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    conversation: impl Wire2Api<DartConversationData> + UnwindSafe,
    message: impl Wire2Api<DartMessage> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_msg",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            let api_conversation = conversation.wire2api();
            let api_message = message.wire2api();
            move |task_callback| Ok(new_msg(api_state, api_conversation, api_message))
        },
    )
}
fn wire_validate_targets_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    targets: impl Wire2Api<Vec<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "validate_targets",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            let api_targets = targets.wire2api();
            move |task_callback| validate_targets(api_state, api_targets)
        },
    )
}
fn wire_cancel_registration_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "cancel_registration",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            move |task_callback| Ok(cancel_registration(api_state))
        },
    )
}
fn wire_get_phase_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_phase",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            move |task_callback| Ok(get_phase(api_state))
        },
    )
}
fn wire_restore_impl(
    port_: MessagePort,
    curr_state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    data: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "restore",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_curr_state = curr_state.wire2api();
            let api_data = data.wire2api();
            move |task_callback| Ok(restore(api_curr_state, api_data))
        },
    )
}
fn wire_new_push_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_push",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            move |task_callback| Ok(new_push(api_state))
        },
    )
}
fn wire_download_attachment_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    attachment: impl Wire2Api<DartAttachment> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "download_attachment",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            let api_state = state.wire2api();
            let api_attachment = attachment.wire2api();
            let api_path = path.wire2api();
            move |task_callback| {
                download_attachment(
                    task_callback.stream_sink(),
                    api_state,
                    api_attachment,
                    api_path,
                )
            }
        },
    )
}
fn wire_download_mmcs_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    attachment: impl Wire2Api<DartMMCSFile> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "download_mmcs",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            let api_state = state.wire2api();
            let api_attachment = attachment.wire2api();
            let api_path = path.wire2api();
            move |task_callback| {
                download_mmcs(
                    task_callback.stream_sink(),
                    api_state,
                    api_attachment,
                    api_path,
                )
            }
        },
    )
}
fn wire_upload_mmcs_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "upload_mmcs",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            let api_state = state.wire2api();
            let api_path = path.wire2api();
            move |task_callback| upload_mmcs(task_callback.stream_sink(), api_state, api_path)
        },
    )
}
fn wire_upload_attachment_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
    mime: impl Wire2Api<String> + UnwindSafe,
    uti: impl Wire2Api<String> + UnwindSafe,
    name: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "upload_attachment",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            let api_state = state.wire2api();
            let api_path = path.wire2api();
            let api_mime = mime.wire2api();
            let api_uti = uti.wire2api();
            let api_name = name.wire2api();
            move |task_callback| {
                upload_attachment(
                    task_callback.stream_sink(),
                    api_state,
                    api_path,
                    api_mime,
                    api_uti,
                    api_name,
                )
            }
        },
    )
}
fn wire_try_auth_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    username: impl Wire2Api<String> + UnwindSafe,
    password: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "try_auth",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            let api_username = username.wire2api();
            let api_password = password.wire2api();
            move |task_callback| try_auth(api_state, api_username, api_password)
        },
    )
}
fn wire_register_ids_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
    validation_data: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "register_ids",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            let api_validation_data = validation_data.wire2api();
            move |task_callback| register_ids(api_state, api_validation_data)
        },
    )
}
fn wire_save_push_impl(
    port_: MessagePort,
    state: impl Wire2Api<RustOpaque<PushState>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "save_push",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_state = state.wire2api();
            move |task_callback| Ok(save_push(api_state))
        },
    )
}
fn wire_save__method__DartAttachment_impl(
    port_: MessagePort,
    that: impl Wire2Api<DartAttachment> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "save__method__DartAttachment",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            move |task_callback| Ok(DartAttachment::save(&api_that))
        },
    )
}
fn wire_restore__static_method__DartAttachment_impl(
    port_: MessagePort,
    saved: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "restore__static_method__DartAttachment",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_saved = saved.wire2api();
            move |task_callback| Ok(DartAttachment::restore(api_saved))
        },
    )
}
fn wire_as_plain__method__DartMessageParts_impl(
    port_: MessagePort,
    that: impl Wire2Api<DartMessageParts> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "as_plain__method__DartMessageParts",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            move |task_callback| Ok(DartMessageParts::as_plain(&api_that))
        },
    )
}
// Section: wrapper structs

// Section: static checks

// Section: allocate functions

// Section: related functions

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        (!self.is_null()).then(|| self.wire2api())
    }
}

impl Wire2Api<bool> for bool {
    fn wire2api(self) -> bool {
        self
    }
}

impl Wire2Api<DartReaction> for i32 {
    fn wire2api(self) -> DartReaction {
        match self {
            0 => DartReaction::Heart,
            1 => DartReaction::Like,
            2 => DartReaction::Dislike,
            3 => DartReaction::Laugh,
            4 => DartReaction::Emphsize,
            5 => DartReaction::Question,
            _ => unreachable!("Invalid variant for DartReaction: {}", self),
        }
    }
}

impl Wire2Api<i32> for i32 {
    fn wire2api(self) -> i32 {
        self
    }
}

impl Wire2Api<u64> for u64 {
    fn wire2api(self) -> u64 {
        self
    }
}
impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

impl Wire2Api<usize> for usize {
    fn wire2api(self) -> usize {
        self
    }
}
// Section: impl IntoDart

impl support::IntoDart for DartAttachment {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.a_type.into_dart(),
            self.part_idx.into_dart(),
            self.uti_type.into_dart(),
            self.size.into_dart(),
            self.mime.into_dart(),
            self.name.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartAttachment {}

impl support::IntoDart for DartAttachmentType {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Inline(field0) => vec![0.into_dart(), field0.into_dart()],
            Self::MMCS(field0) => vec![1.into_dart(), field0.into_dart()],
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartAttachmentType {}
impl support::IntoDart for DartBalloonBody {
    fn into_dart(self) -> support::DartAbi {
        vec![self.bid.into_dart(), self.data.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartBalloonBody {}

impl support::IntoDart for DartChangeParticipantMessage {
    fn into_dart(self) -> support::DartAbi {
        vec![self.new_participants.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartChangeParticipantMessage {}

impl support::IntoDart for DartConversationData {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.participants.into_dart(),
            self.cv_name.into_dart(),
            self.sender_guid.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartConversationData {}

impl support::IntoDart for DartEditMessage {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.tuuid.into_dart(),
            self.edit_part.into_dart(),
            self.new_parts.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartEditMessage {}

impl support::IntoDart for DartIMessage {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.id.into_dart(),
            self.sender.into_dart(),
            self.after_guid.into_dart(),
            self.conversation.into_dart(),
            self.message.into_dart(),
            self.sent_timestamp.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartIMessage {}

impl support::IntoDart for DartIconChangeMessage {
    fn into_dart(self) -> support::DartAbi {
        vec![self.file.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartIconChangeMessage {}

impl support::IntoDart for DartIndexedMessagePart {
    fn into_dart(self) -> support::DartAbi {
        vec![self.0.into_dart(), self.1.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartIndexedMessagePart {}

impl support::IntoDart for DartMessage {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Message(field0) => vec![0.into_dart(), field0.into_dart()],
            Self::RenameMessage(field0) => vec![1.into_dart(), field0.into_dart()],
            Self::ChangeParticipants(field0) => vec![2.into_dart(), field0.into_dart()],
            Self::React(field0) => vec![3.into_dart(), field0.into_dart()],
            Self::Delivered => vec![4.into_dart()],
            Self::Read => vec![5.into_dart()],
            Self::Typing => vec![6.into_dart()],
            Self::Unsend(field0) => vec![7.into_dart(), field0.into_dart()],
            Self::Edit(field0) => vec![8.into_dart(), field0.into_dart()],
            Self::IconChange(field0) => vec![9.into_dart(), field0.into_dart()],
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartMessage {}
impl support::IntoDart for DartMessagePart {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Text(field0) => vec![0.into_dart(), field0.into_dart()],
            Self::Attachment(field0) => vec![1.into_dart(), field0.into_dart()],
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartMessagePart {}
impl support::IntoDart for DartMessageParts {
    fn into_dart(self) -> support::DartAbi {
        vec![self.0.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartMessageParts {}

impl support::IntoDart for DartMMCSFile {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.signature.into_dart(),
            self.object.into_dart(),
            self.url.into_dart(),
            self.key.into_dart(),
            self.size.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartMMCSFile {}

impl support::IntoDart for DartNormalMessage {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.parts.into_dart(),
            self.body.into_dart(),
            self.effect.into_dart(),
            self.reply_guid.into_dart(),
            self.reply_part.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartNormalMessage {}

impl support::IntoDart for DartReactMessage {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.to_uuid.into_dart(),
            self.to_part.into_dart(),
            self.enable.into_dart(),
            self.reaction.into_dart(),
            self.to_text.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartReactMessage {}

impl support::IntoDart for DartReaction {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Heart => 0,
            Self::Like => 1,
            Self::Dislike => 2,
            Self::Laugh => 3,
            Self::Emphsize => 4,
            Self::Question => 5,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartReaction {}
impl support::IntoDart for DartRecievedMessage {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Message { msg } => vec![0.into_dart(), msg.into_dart()],
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartRecievedMessage {}
impl support::IntoDart for DartRenameMessage {
    fn into_dart(self) -> support::DartAbi {
        vec![self.new_name.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartRenameMessage {}

impl support::IntoDart for DartUnsendMessage {
    fn into_dart(self) -> support::DartAbi {
        vec![self.tuuid.into_dart(), self.edit_part.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DartUnsendMessage {}

impl support::IntoDart for MMCSTransferProgress {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.prog.into_dart(),
            self.total.into_dart(),
            self.file.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for MMCSTransferProgress {}

impl support::IntoDart for RegistrationPhase {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::NOT_STARTED => 0,
            Self::WANTS_USER_PASS => 1,
            Self::WANTS_VALID_ID => 2,
            Self::REGISTERED => 3,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for RegistrationPhase {}
impl support::IntoDart for TransferProgress {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.prog.into_dart(),
            self.total.into_dart(),
            self.attachment.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for TransferProgress {}

// Section: executor

support::lazy_static! {
    pub static ref FLUTTER_RUST_BRIDGE_HANDLER: support::DefaultHandler = Default::default();
}

#[cfg(not(target_family = "wasm"))]
#[path = "bridge_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;
